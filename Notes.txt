QN.NO : 01               IAM USER

An IAM user is a resource in IAM that has associated credentials and permissions. 

An IAM user can represent a person or an application that uses its credentials to make AWS requests. 

This is typically referred to as a service account.

An IAM User is an entity created in AWS that provides a way to interact with AWS resources. 

The main purpose of IAM Users is that they can sign in to the AWS Management Console and can make requests 
to the AWS services. The newly created IAM users have no password and no access key.

An AWS IAM user granted administrative privileges can do almost everything a root user can do, 
except for a few tasks that are restricted to the root account.

Note that there is a limit of two access keys per identity and a hard limit of 5,000 IAM users per AWS account. 
Upon the request it can be extended to 1,00,000 users.
An AWS root or IAM admin can create an IAM user on the IAM dashboard of the AWS Console. 
You have to provide the AWS username, password, and AWS account number.



QN.NO : 02                     AWS Key Credentials

The access key aws_access_key_id is required to connect to Amazon Keyspaces programmatically. 

WS uses the security credentials to authenticate and authorize your requests. 
For example, if you want to download a protected file from an Amazon Simple Storage Service (Amazon S3) bucket, 
your credentials must allow that access.



QN.NO : 03                  IAM Role vs IAM User Credentials

An IAM user has permanent long-term credentials and is used to directly interact with AWS services. 
An IAM role does not have any credentials and cannot make direct requests to AWS services. 
IAM roles are meant to be assumed by authorized entities, such as IAM users, applications, or an AWS service such as EC2.


QN.NO : 04                         Benefits off IAM role.

Using roles in this way has several benefits. Because role credentials are temporary and updated automatically, 
you don't have to manage credentials, and you don't have to worry about long-term security risks. 

In addition, if you use a single role for multiple instances, you can make a change to that one role and 
the change propagates automatically to all the instances.




QN.NO : 05       How to access query string parameter and the path parameter in the flask

01. Query string parameter argument can be extracted in a flask only using the request Object:
You can access query string parameters using the request object, which is part of Flask's core functionality. 
syntax:
request.args.get()

02. Path parameters can be accessed in the flask only using Function Arguments:
You can also extract path parameters as arguments to a route function. 
Flask will automatically map URL parameters to function arguments with the same name.
syntax:
def upload(filename):
    return "file name is {}".format(filename)







QN.NO : 06               which is better to use path parameter or query string parameter?


The choice between path parameters and query string parameters often depends on your specific use case and the design of your application. However, if you're looking for a general guideline in terms of major advantages, here's a simplified breakdown:

Path Parameters are typically favored for:

Semantic URLs: When you want to create meaningful and descriptive URLs that clearly convey the purpose or identity of the resource being accessed.

SEO and Usability: When optimizing your website for search engines and user experience, as descriptive URLs can improve both.

RESTful APIs: When following RESTful principles, path parameters are commonly used for resource identification and navigation.

Query String Parameters are typically favored for:

Optional Parameters: When dealing with optional parameters that modify or filter the request without altering the core structure of the URL.

Flexibility: When you need the flexibility to add or change parameters without affecting the URL's structure.

APIs and Web Forms: When working with APIs or web forms, query string parameters are a common and convenient way to pass data to the server.

Caching: When working with caching mechanisms, as changes in query string parameters are often treated as separate requests by caching systems.

In many cases, web applications use a combination of both path and query string parameters to strike a balance between meaningful URLs and flexibility in handling optional parameters. Ultimately, the choice should align with your application's specific requirements and usability considerations.






QN.NO : 07              why we need to give name as argument in flask(__name__)

The flask object implements a WSGI application and acts as the central object. 
It is passed the name of the module or package of the application. 
Once it is created it will act as a central registry for the view functions, the URL rules, 
template configuration and much more.

The name of the package is used to resolve resources from inside the package or the folder the module is 
contained in depending on if the package parameter resolves to an actual python package 
(a folder with an __init__.py file inside) or a standard module (just a .py file).

About the First Parameter
The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.

So it’s important what you provide there. If you are using a single module, __name__ is always the correct value. If you however are using a package, it’s usually recommended to hardcode the name of your package there.

For example if your application is defined in yourapplication/app.py you should create it with one of the two versions below:

app = Flask('yourapplication')
app = Flask(__name__.split('.')[0])

Why is that? The application will work even with __name__, thanks to how resources are looked up. 
However it will make debugging more painful. Certain extensions can make assumptions based on 
the import name of your application. For example the Flask-SQLAlchemy extension will look for the code 
in your application that triggered an SQL query in debug mode. If the import name is not properly set up, 
that debugging information is lost. (For example it would only pick up SQL queries in yourapplication.app 
and not yourapplication.views.frontend)